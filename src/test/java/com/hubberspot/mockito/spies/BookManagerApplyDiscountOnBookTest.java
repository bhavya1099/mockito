// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=applyDiscountOnBook_9e7ce6a645
ROOST_METHOD_SIG_HASH=applyDiscountOnBook_29811002e7
"""
  Scenario 1: Validate the discount applied on the book price when valid bookId and discountRate are provided
  Details:
    TestName: validateDiscountAppliedOnValidBookIdAndDiscountRate.
    Description: This test is meant to check whether the discount is correctly applied on the book price when valid bookId and discountRate are provided. The target scenario is when the user wants to apply a certain discount on a particular book.
  Execution:
    Arrange: Mock the bookService to return a specific book when findBook method is called with the provided bookId. Also mock the getAppliedDiscount method to return a discounted price.
    Act: Invoke the applyDiscountOnBook method with the appropriate bookId and discountRate.
    Assert: Use JUnit assertions to compare the actual discounted price against the expected discounted price.
  Validation:
    The assertion aims to verify that the discount is correctly applied on the book price. The expected result is based on the assumption that the bookService methods work correctly. This test is significant as it ensures that the users get the correct discounted price when they apply a discount on a book.
  Scenario 2: Validate the behaviour when invalid bookId is provided
  Details:
    TestName: validateBehaviourOnInvalidBookId.
    Description: This test is meant to check the behaviour of the method when an invalid bookId is provided. The target scenario is when the user provides an invalid bookId.
  Execution:
    Arrange: Mock the bookService to throw an exception when findBook method is called with the invalid bookId.
    Act: Invoke the applyDiscountOnBook method with the invalid bookId and a valid discountRate.
    Assert: Use JUnit assertions to expect an exception.
  Validation:
    The assertion aims to verify that an exception is thrown when an invalid bookId is provided. The expected result is based on the assumption that the bookService methods work correctly. This test is significant as it ensures that the application behaves as expected when invalid input is provided.
  Scenario 3: Validate the behaviour when negative discountRate is provided
  Details:
    TestName: validateBehaviourOnNegativeDiscountRate.
    Description: This test is meant to check the behaviour of the method when a negative discountRate is provided. The target scenario is when the user provides a negative discountRate.
  Execution:
    Arrange: Mock the bookService to return a specific book when findBook method is called with the provided bookId. Also mock the getAppliedDiscount method to throw an exception when a negative discountRate is provided.
    Act: Invoke the applyDiscountOnBook method with a valid bookId and a negative discountRate.
    Assert: Use JUnit assertions to expect an exception.
  Validation:
    The assertion aims to verify that an exception is thrown when a negative discountRate is provided. The expected result is based on the assumption that the bookService methods work correctly. This test is significant as it ensures that the application behaves as expected when invalid input is provided.
"""
*/
// ********RoostGPT********
package com.hubberspot.mockito.spies;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import java.time.LocalDate;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.Mockito.when;
import org.junit.experimental.categories.Category;
import org.junit.Test;

@Category({ Categories.applyDiscountOnBook.class, Categories.findBook.class, Categories.getAppliedDiscount.class,
		Categories.roostTestTag1.class, Categories.roostTestTag2.class })
public class BookManagerApplyDiscountOnBookTest {

	@Mock
	private BookService bookService;

	private BookManager bookManager;

	@BeforeEach
	public void setup() {
		MockitoAnnotations.initMocks(this);
		bookManager = new BookManager(bookService);
	}

	@Test
	public void validateDiscountAppliedOnValidBookIdAndDiscountRate() {
		String bookId = "book1";
		int discountRate = 10;
		Book book = new Book(bookId, "Test Book", 200, LocalDate.now());
		when(bookService.findBook(bookId)).thenReturn(book);
		when(bookService.getAppliedDiscount(book, discountRate)).thenReturn(180);
		int actualDiscountedPrice = bookManager.applyDiscountOnBook(bookId, discountRate);
		assertEquals(180, actualDiscountedPrice);
	}

	@Test
	public void validateBehaviourOnInvalidBookId() {
		String invalidBookId = "invalidBookId";
		int discountRate = 10;
		when(bookService.findBook(invalidBookId)).thenThrow(RuntimeException.class);
		assertThrows(RuntimeException.class, () -> bookManager.applyDiscountOnBook(invalidBookId, discountRate));
	}

	@Test
	public void validateBehaviourOnNegativeDiscountRate() {
		String bookId = "book1";
		int negativeDiscountRate = -10;
		Book book = new Book(bookId, "Test Book", 200, LocalDate.now());
		when(bookService.findBook(bookId)).thenReturn(book);
		when(bookService.getAppliedDiscount(book, negativeDiscountRate)).thenThrow(RuntimeException.class);
		assertThrows(RuntimeException.class, () -> bookManager.applyDiscountOnBook(bookId, negativeDiscountRate));
	}

}