// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=updatePrice_ab684f4674
ROOST_METHOD_SIG_HASH=updatePrice_c260551a47
Scenario 1: Update the price of an existing book
Details:
  TestName: testUpdatePriceOfExistingBook
  Description: This test is meant to check if the method correctly updates the price of an existing book in the repository.
Execution:
  Arrange: Create a mock for the BookRepository and a Book object with a predefined bookId and original price.
  Act: Invoke the updatePrice method with the predefined bookId and a new price.
  Assert: Use JUnit assertions to compare the new price of the book with the updated price.
Validation:
  The assertion aims to verify that the book's price was correctly updated in the repository. This is important to ensure that the book's price information is accurate and up-to-date.
Scenario 2: Update the price of a non-existing book
Details:
  TestName: testUpdatePriceOfNonExistingBook
  Description: This test is meant to check how the method behaves when trying to update the price of a book that does not exist in the repository.
Execution:
  Arrange: Create a mock for the BookRepository without any Book objects.
  Act: Invoke the updatePrice method with a random bookId and a new price.
  Assert: Use JUnit assertions to verify if an exception is thrown.
Validation:
  The assertion aims to verify that an exception is thrown when trying to update the price of a non-existing book. This is important to ensure that the application behaves correctly when facing this edge case.
Scenario 3: Update the price to a negative value
Details:
  TestName: testUpdatePriceToNegativeValue
  Description: This test is meant to check how the method behaves when trying to update the book's price to a negative value.
Execution:
  Arrange: Create a mock for the BookRepository and a Book object with a predefined bookId and original price.
  Act: Invoke the updatePrice method with the predefined bookId and a negative price.
  Assert: Use JUnit assertions to verify if an exception is thrown or if the price remains unchanged.
Validation:
  The assertion aims to verify that the book's price cannot be updated to a negative value. This is important to ensure that the application handles invalid inputs correctly.
Scenario 4: Update the price to a zero value
Details:
  TestName: testUpdatePriceToZeroValue
  Description: This test is meant to check if the method correctly updates the price of an existing book to zero in the repository.
Execution:
  Arrange: Create a mock for the BookRepository and a Book object with a predefined bookId and original price.
  Act: Invoke the updatePrice method with the predefined bookId and a zero price.
  Assert: Use JUnit assertions to compare the new price of the book with the updated price.
Validation:
  The assertion aims to verify that the book's price was correctly updated to zero in the repository. This is important to ensure that the book's price information is accurate and up-to-date.
*/
// ********RoostGPT********
package com.hubberspot.mockito.bdd.behavior_verification;

import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import static org.mockito.Mockito.*;
import java.time.LocalDate;
import org.junit.jupiter.api.*;

@Tag("com.hubberspot.mockito.behavior.verification")
@Tag("com.hubberspot.mockito.behavior.verification.findBookById")
@Tag("com.hubberspot.mockito.behavior.verification.setPrice")
@Tag("com.hubberspot.mockito.behavior.verification.save")
@Tag("com.hubberspot.mockito.bdd.behavior_verification")
@Tag("com.hubberspot.mockito.bdd.behavior_verification.updatePrice")
@Tag("roostTestTag1")
@Tag("roostTestTag2")
@ExtendWith(MockitoExtension.class)
public class BookServiceUpdatePriceTest {

	@Mock
	private BookRepository bookRepository;

	@InjectMocks
	private BookService bookService;

	@Test
	@Tag("valid")
	public void testUpdatePriceOfExistingBook() {
		String bookId = "123";
		int originalPrice = 50;
		int newPrice = 60;
		Book book = new Book(bookId, "testTitle", originalPrice, LocalDate.now());
		when(bookRepository.findBookById(bookId)).thenReturn(book);
		bookService.updatePrice(bookId, newPrice);
		verify(bookRepository).save(book);
		assert (book.getPrice() == newPrice);
	}

	@Test
	@Tag("invalid")
	public void testUpdatePriceOfNonExistingBook() {
		String bookId = "456";
		int newPrice = 70;
		when(bookRepository.findBookById(bookId)).thenReturn(null);
		assertThrows(NullPointerException.class, () -> bookService.updatePrice(bookId, newPrice));
	}

	@Test
	@Tag("boundary")
	public void testUpdatePriceToNegativeValue() {
		String bookId = "789";
		int originalPrice = 80;
		int newPrice = -10;
		Book book = new Book(bookId, "testTitle", originalPrice, LocalDate.now());
		when(bookRepository.findBookById(bookId)).thenReturn(book);
		assertThrows(IllegalArgumentException.class, () -> bookService.updatePrice(bookId, newPrice));
	}

	@Test
	@Tag("valid")
	public void testUpdatePriceToZeroValue() {
		String bookId = "000";
		int originalPrice = 90;
		int newPrice = 0;
		Book book = new Book(bookId, "testTitle", originalPrice, LocalDate.now());
		when(bookRepository.findBookById(bookId)).thenReturn(book);
		bookService.updatePrice(bookId, newPrice);
		verify(bookRepository).save(book);
		assert (book.getPrice() == newPrice);
	}

}