// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=updatePrice_ab684f4674
ROOST_METHOD_SIG_HASH=updatePrice_c260551a47
"""
Scenario 1: Valid Book ID and price update
Details:
  TestName: updatePriceWithValidBookIdAndPrice.
  Description: This test is meant to check the functionality when a valid book ID and a correct price are provided.
Execution:
  Arrange: Mock the 'bookRepository.findBookById()' to return a valid book.
  Act: Invoke the 'updatePrice()' method with a valid book ID and a new price.
  Assert: Check that 'setPrice()' and 'bookRepository.save()' were called with the correct parameters.
Validation:
  Validate that the book price is updated correctly when valid data is provided. This is significant in the context of maintaining accurate book price information in the system.
Scenario 2: Invalid Book ID
Details:
  TestName: updatePriceWithInvalidBookId.
  Description: This test is meant to check how the system handles an invalid Book ID.
Execution:
  Arrange: Mock the 'bookRepository.findBookById()' to return null.
  Act: Invoke 'updatePrice()' method with an invalid book ID and a new price.
  Assert: Check that 'setPrice()' and 'bookRepository.save()' were not called.
Validation:
  Validate that the system behaves as expected when given an invalid Book ID. This is important to prevent saving null values in the database and maintain data integrity.
Scenario 3: Negative Price
Details:
  TestName: updatePriceWithNegativePrice.
  Description: This test is meant to check how the system handles a negative price.
Execution:
  Arrange: Mock the 'bookRepository.findBookById()' to return a valid book.
  Act: Invoke 'updatePrice()' method with a valid book ID and a negative price.
  Assert: Check that 'setPrice()' was not called and 'bookRepository.save()' was not called.
Validation:
 Validate that the system does not accept negative prices as it is not a valid business scenario. This helps prevent database corruption and maintains business rules.

Scenario 4: Book ID is null
Details:
  TestName: updatePriceWithNullBookId.
  Description: This test is meant to check the system's reaction to a null Book ID.
Execution:
  Arrange: No arrange required for this scenario as input is null.
  Act: Invoke 'updatePrice()' method with a null book ID and a positive price.
  Assert: Check that 'setPrice()' and 'bookRepository.save()' were not called.
Validation:
 Validate that the system can handle null values and does not attempt to fetch or update data for a null book. This prevents possible NullPointerExceptions and maintains the integrity of the application.
Scenario 5: Updating Price to the Same Value
Details:
  TestName: updatePriceWithSameValue.
  Description: This test is meant to check how the system handles the scenario when updating the price to its current value.
Execution:
  Arrange: Mock the 'bookRepository.findBookById()' to return a book with a price that matches the updated price.
  Act: Invoke 'updatePrice()' method with a valid book ID and the current price as the updated price.
  Assert: Check that 'setPrice()' was called but 'bookRepository.save()' was not called.
Validation:
 Validate that the system does not update the book price if the new price is the same as the current price. This avoids unnecessary database operations, improving efficiency.
"""
*/
// ********RoostGPT********
package com.hubberspot.mockito.argument_matchers;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import java.time.LocalDate;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import java.util.List;
import org.junit.jupiter.api.*;

@Tag("com.hubberspot.mockito.behavior.verification")
@Tag("com.hubberspot.mockito.behavior.verification.findBookById")
@Tag("com.hubberspot.mockito.behavior.verification.setPrice")
@Tag("com.hubberspot.mockito.behavior.verification.save")
@Tag("com.hubberspot.mockito.argument_matchers")
@Tag("com.hubberspot.mockito.argument_matchers.updatePrice")
@Tag("roostTest1")
@Tag("roostTest2")
class BookServiceUpdatePriceTest {

	private BookRepository bookRepository = mock(BookRepository.class);

	private BookService bookService = new BookService(bookRepository);

	@Test
	void updatePriceWithValidBookIdAndPrice() {
		Book book = new Book("b1", "Book 1", 10, LocalDate.now(), false);
		when(bookRepository.findBookById("b1")).thenReturn(book);
		bookService.updatePrice("b1", 20);
		verify(bookRepository, times(1)).findBookById(eq("b1"));
		verify(bookRepository, times(1)).save(eq(book));
		Assertions.assertEquals(20, book.getPrice());
	}

	@Test
    void updatePriceWithInvalidBookId() {
        when(bookRepository.findBookById(anyString())).thenReturn(null);
        Assertions.assertThrows(IllegalArgumentException.class, () -> {
            bookService.updatePrice("b2", 20);
        });
        verify(bookRepository, times(1)).findBookById(eq("b2"));
        verify(bookRepository, never()).save(any(Book.class));
    }

	@Test
	void updatePriceWithNegativePrice() {
		Book book = new Book("b1", "Book 1", 10, LocalDate.now(), false);
		when(bookRepository.findBookById("b1")).thenReturn(book);
		Assertions.assertThrows(IllegalArgumentException.class, () -> {
			bookService.updatePrice("b1", -20);
		});
		verify(bookRepository, times(1)).findBookById(eq("b1"));
		verify(bookRepository, never()).save(any(Book.class));
	}

	@Test
	void updatePriceWithNullBookId() {
		Assertions.assertThrows(IllegalArgumentException.class, () -> {
			bookService.updatePrice(null, 20);
		});
		verify(bookRepository, never()).findBookById(anyString());
		verify(bookRepository, never()).save(any(Book.class));
	}

	@Test
	void updatePriceWithSameValue() {
		Book book = new Book("b1", "Book 1", 20, LocalDate.now(), false);
		when(bookRepository.findBookById("b1")).thenReturn(book);
		bookService.updatePrice("b1", 20);
		verify(bookRepository, times(1)).findBookById(eq("b1"));
		verify(bookRepository, times(1)).save(eq(book));
		Assertions.assertEquals(20, book.getPrice());
	}

}