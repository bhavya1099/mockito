// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=getBookByTitleAndPriceAndIsDigital_8cac1b5ded
ROOST_METHOD_SIG_HASH=getBookByTitleAndPriceAndIsDigital_af372a2dbe

```
Scenario 1: Retrieve a digital book by title and price
Details:
  TestName: retrieveDigitalBookByTitleAndPrice
  Description: This test verifies that the method correctly retrieves a digital book based on the given title and price.
Execution:
  Arrange: Mock the bookRepository to return a predefined Book object when findBookByTitleAndPriceAndIsDigital is called with specific title, price, and isDigital=true.
  Act: Call getBookByTitleAndPriceAndIsDigital with the respective title, price, and isDigital=true.
  Assert: Check if the returned Book object is the same as the mocked one.
Validation:
  The assertion checks whether the book retrieved is as expected, ensuring the method correctly queries and returns the correct book. This test is significant for validating that digital books can be accurately fetched from the repository based on title and price.

Scenario 2: Retrieve a physical book by title and price
Details:
  TestName: retrievePhysicalBookByTitleAndPrice
  Description: This test aims to ensure that the method can retrieve a physical (non-digital) book using a specified title and price.
Execution:
  Arrange: Setup a mock return value for bookRepository.findBookByTitleAndPriceAndIsDigital with specific parameters where isDigital=false.
  Act: Invoke getBookByTitleAndPriceAndIsDigital with title, price, and isDigital=false.
  Assert: Validate that the returned Book object matches the expected mock.
Validation:
  This test confirms the ability of the method to differentiate and correctly fetch physical books. It's crucial for scenarios where users are looking for non-digital versions and ensures accurate retrieval based on the book's physical availability.

Scenario 3: Book not found with given criteria
Details:
  TestName: bookNotFoundWithGivenCriteria
  Description: Test to verify that the method returns null when no book matches the search criteria.
Execution:
  Arrange: Configure the bookRepository to return null when no matching book is found.
  Act: Call getBookByTitleAndPriceAndIsDigital with non-matching title, price, and isDigital status.
  Assert: Assert that the result is null.
Validation:
  This test checks the method's robustness in handling cases where no book matches the given criteria, which is important for correctly informing the user or the system about the absence of such a book.

Scenario 4: Handling invalid price input
Details:
  TestName: handleInvalidPriceInput
  Description: Ensure that the method behaves correctly when provided with an invalid price (e.g., negative value).
Execution:
  Arrange: Assume the repository handles any price input without throwing an error and returns null for non-existent books.
  Act: Call getBookByTitleAndPriceAndIsDigital with a valid title, negative price, and valid isDigital status.
  Assert: Assert that the result is null or appropriate handling is performed.
Validation:
  This scenario validates that the system gracefully handles incorrect price inputs, which helps in maintaining system stability and user experience by not breaking down on invalid inputs.

Scenario 5: Exact match required for successful retrieval
Details:
  TestName: exactMatchRequiredForSuccessfulRetrieval
  Description: This test checks that all parameters (title, price, isDigital) must exactly match a book record in the repository to retrieve it.
Execution:
  Arrange: Set up a mock book with specific title, price, and isDigital status. Ensure the repository only returns this book when all parameters match exactly.
  Act: Call getBookByTitleAndPriceAndIsDigital with exact title, price, and isDigital parameters.
  Assert: Assert that the returned book matches the mock.
Validation:
  The test confirms that the method strictly requires an exact match on all parameters, which is critical for ensuring accurate data retrieval and avoiding incorrect or ambiguous results.
```
*/

// ********RoostGPT********

package com.hubberspot.mockito.argument_matchers;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import java.time.LocalDate;
import static org.mockito.Mockito.when;
import static org.assertj.core.api.Assertions.assertThat;
import org.junit.jupiter.api.*;
import java.util.List;

public class BookServiceGetBookByTitleAndPriceAndIsDigitalTest {

	@Mock
	private BookRepository bookRepository;

	private BookService bookService;

	@BeforeEach
	public void setUp() {
		MockitoAnnotations.initMocks(this);
		bookService = new BookService(bookRepository);
	}

	@Test
	@Tag("valid")
	public void retrieveDigitalBookByTitleAndPrice() {
		Book expectedBook = new Book("1", "Effective Java", 450, LocalDate.now(), true);
		when(bookRepository.findBookByTitleAndPriceAndIsDigital("Effective Java", 450, true)).thenReturn(expectedBook);
		Book actualBook = bookService.getBookByTitleAndPriceAndIsDigital("Effective Java", 450, true);
		assertThat(actualBook).isEqualTo(expectedBook);
	}

	@Test
	@Tag("valid")
	public void retrievePhysicalBookByTitleAndPrice() {
		Book expectedBook = new Book("2", "Java Concurrency in Practice", 500, LocalDate.now(), false);
		when(bookRepository.findBookByTitleAndPriceAndIsDigital("Java Concurrency in Practice", 500, false))
			.thenReturn(expectedBook);
		Book actualBook = bookService.getBookByTitleAndPriceAndIsDigital("Java Concurrency in Practice", 500, false);
		assertThat(actualBook).isEqualTo(expectedBook);
	}

	@Test
    @Tag("invalid")
    public void bookNotFoundWithGivenCriteria() {
        when(bookRepository.findBookByTitleAndPriceAndIsDigital("Nonexistent Book", 1000, true)).thenReturn(null);
        Book actualBook = bookService.getBookByTitleAndPriceAndIsDigital("Nonexistent Book", 1000, true);
        assertThat(actualBook).isNull();
    }

	@Test
    @Tag("boundary")
    public void handleInvalidPriceInput() {
        when(bookRepository.findBookByTitleAndPriceAndIsDigital("Clean Code", -100, true)).thenReturn(null);
        Book actualBook = bookService.getBookByTitleAndPriceAndIsDigital("Clean Code", -100, true);
        assertThat(actualBook).isNull();
    }

	@Test
	@Tag("integration")
	public void exactMatchRequiredForSuccessfulRetrieval() {
		Book expectedBook = new Book("3", "Refactoring", 600, LocalDate.now(), true);
		when(bookRepository.findBookByTitleAndPriceAndIsDigital("Refactoring", 600, true)).thenReturn(expectedBook);
		Book actualBook = bookService.getBookByTitleAndPriceAndIsDigital("Refactoring", 600, true);
		assertThat(actualBook).isEqualTo(expectedBook);
	}

}